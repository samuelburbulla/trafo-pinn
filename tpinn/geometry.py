import deepxde as dde
import torch


class Transformed(dde.geometry.Geometry):
    """Transformed geometry.
    
    A transformed geometry that is generated by mapping
    a reference domain to global coordinates.

    Points are sampled in the reference domain and transformed
    to global coordinates.

    Args:
        ref: The reference geometry.
        to_global: The mapping from local to global coordinates.
        to_local: (optional) The mapping from global to local coordinates.
            By default, we assume that `to_global` concatenates the local and
            global coordinates and, therefore, the default `to_local` only 
            extracts the ref.dim first elements of the global coordinates.
    """

    ref: dde.geometry.Geometry
    to_global: callable
    to_local: callable

    def __init__(self, ref, to_global, to_local=None):
        # Default to_local
        if to_local is None:
            to_local = lambda y: y[:, :ref.dim]

        self.ref = ref
        self.to_global_ = to_global
        self.to_local_ = to_local

        # Validate transformation
        x = self.ref.uniform_points(3**self.ref.dim)
        z = self.to_local(self.to_global(x))
        if not (z - x < 1e-6).all():
            print(f"{z.T}\n  != \n{x.T}")
            raise ValueError("Transformation does not satisfy"\
                             "`to_local(to_global(x)) = x`!")

        bbox = [to_global(torch.tensor(b).unsqueeze(0)) for b in ref.bbox]
        super().__init__(ref.dim, bbox, torch.nan)
        self.dim = bbox[0].shape[-1] - ref.dim

    def to_global(self, x):
        """Transform points from local to global coordinates."""
        numpy = (type(x) != torch.Tensor)
        if numpy:
            x = torch.tensor(x)

        y = self.to_global_(x)

        if numpy:
            y = y.detach().numpy()

        return y

    def to_local(self, y):
        """Transform points from global to local coordinates."""
        numpy = (type(y) != torch.Tensor)
        if numpy:
            y = torch.tensor(y)

        x = self.to_local_(y)

        if numpy:
            x = x.detach().numpy()

        return x

    def inside(self, x):
        """Return whether the points are inside the geometry."""
        return self.ref.inside(self.to_local(x))
    
    def on_boundary(self, x):
        """Return if x is on the boundary of the geometry."""
        return self.ref.on_boundary(self.to_local(x))

    def random_points(self, n, random="pseudo"):
        """Return random points."""
        x = self.ref.random_points(n, random)
        return self.to_global(x)
    
    def uniform_points(self, n):
        """Return uniform points."""
        x = self.ref.uniform_points(n)
        return self.to_global(x)

    def random_boundary_points(self, n, random="pseudo"):
        """Return random boundary points."""
        x = self.ref.random_boundary_points(n, random)
        return self.to_global(x)
    
    def uniform_boundary_points(self, n):
        """Return uniform boundary points."""
        x = self.ref.uniform_boundary_points(n)
        return self.to_global(x)
    
    def distance2boundary(self, x, dirn=None):
        """Return distance to boundary."""

        # Implement distance2boundary for Rectangle
        if type(self.ref) == dde.geometry.Rectangle:
            x = self.to_local(x)
            dist = 4**self.ref.dim
            for i in range(self.ref.dim):
                dist *= x[:, i:i+1] * (1 - x[:, i:i+1])
            return dist
        
        else:
            return self.ref.distance2boundary(self.to_local(x), dirn)
